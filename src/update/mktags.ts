import { ExecFileOptionsWithStringEncoding } from "child_process";
import { exiftool } from '../exiftool'
import * as process from 'process'
import * as _fs from 'fs'
import * as _path from 'path'

// THIS IS SAUSAGECODE. JUDGE ME NOT BY MY SAUSAGE. 

// ☠☠ SCROLL DOWN AT YOUR OWN PERIL ☠☠

const globule = require('globule')

function ellipsize(str: string, max: number) {
  return (str.length < max) ? str : str.substring(0, max - 1) + '…'
}

function usage() {
  console.log('Usage: `npm run mktags IMG_DIR`')
  console.log('\nRebuilds src/tags.ts from tags found in IMG_DIR.')
  process.exit(1)
}

const root = process.argv[2]
const files: string[] = globule.find(`${root}/**/*.jpg`)

if (files.length === 0) {
  console.error(`No files found in ${root}`)
  usage()
}

function valueType(value: any): string {
  if (Array.isArray(value)) {
    if (value.length === 0) {
      return 'any[]'
    } else {
      return `${valueType(value[0])}[]`
    }
  } else {
    return typeof value
  }
}

class Tag {
  values: any[] = []
  constructor(readonly tag: string) {
  } // tslint:disable-line

  get group(): string { return this.tag.split(':')[0] }
  get withoutGroup(): string { return this.tag.split(':')[1] }
  get valueType(): string {
    const n = this.withoutGroup
    const firstValue = this.values[0]
    if (Array.isArray(firstValue)) {
      return valueType(firstValue)
    } else if (n === 'DateStampMode' || n === 'Sharpness' || n === 'Firmware') {
      return 'string'
    } else if (n.includes('DateStamp')) {
      return 'ExifDate'
    } else if (n.includes('TimeStamp')) {
      return 'ExifTime'
    } else if (n.includes('Date')) {
      return 'ExifDateTime'
    } else {
      return valueType(firstValue)
    }
  }

  popIcon(totalValues: number): string {
    const f = this.values.length / totalValues
    return (f > .7) ? '★★★' : (f > .2) ? '★★☆' : '☆☆☆' // arbitrary is arbitrary
  }

  example(): string {
    return ellipsize(JSON.stringify(this.values[0]), 80)
  }
}
type GroupedTags = { [groupName: string]: Tag[] }

class TagMap {
  readonly map = new Map<string, Tag>()
  private maxValueCount = 0

  tag(tag: string) {
    const prevTag = this.map.get(tag)
    if (prevTag) {
      return prevTag
    } else {
      const t = new Tag(tag)
      this.map.set(tag, t)
      return t
    }
  }
  add(tag: string, value: any) {
    const values = this.tag(tag).values
    values.push(value)
    this.maxValueCount = Math.max(values.length, this.maxValueCount)
  }
  tags(): Tag[] {
    const minValues = this.maxValueCount * .005
    const allTags = Array.from(this.map.values())
    console.log(`Skipping the following tags due to < ${minValues} occurances:`)
    console.log(allTags.filter(a => a.values.length < minValues).map(t => t.tag).join(', '))
    return allTags.filter(a => a.values.length >= minValues)
  }
  groupedTags(): GroupedTags {
    const groupedTags: GroupedTags = {}
    this.tags().forEach(tag => {
      const key = tag.group;
      (groupedTags[key] || (groupedTags[key] = [])).push(tag)
    })
    return groupedTags
  }
}

function cmp(a: any, b: any): number {
  return a > b ? 1 : a < b ? -1 : 0
}

const tagMap = new TagMap()

const saneTagRe = /^[a-z0-9_]+:[a-z0-9_]+$/i

const start = Date.now()
Promise.all(files.map(file => {
  return exiftool.readGrouped(file).then((metadata: any) => {
    Object.keys(metadata).forEach(key => {
      if (saneTagRe.exec(key)) { tagMap.add(key, metadata[key]) }
    })
    process.stdout.write('.')
  }).catch(err => console.log(err))
})).then(() => {
  console.log(`\nRead ${tagMap.map.size} unique tags from ${files.length} files. `)
  const elapsedMs = Date.now() - start
  console.log(`Parsing took ${elapsedMs}ms (${(elapsedMs / files.length).toFixed(1)}ms / file)`)
  const destFile = _path.resolve(__dirname, '../../src/tags.ts')
  const tagWriter = _fs.createWriteStream(destFile)
  tagWriter.write('/* tslint:disable:class-name */\n') // because of ICC_Profile
  tagWriter.write(`import { ExifDate, ExifTime, ExifDateTime } from './datetime'\n\n`)
  tagWriter.write(`// Autogenerated by "npm run mktags" on ${new Date().toDateString()}.\n\n`)
  tagWriter.write('// Comments by each tag include likelihood (★★★ is > 70%, ☆☆☆ is rare)\n')
  tagWriter.write('// An example value, JSON stringified, follows the likelihood rating.\n')
  const groupedTags = tagMap.groupedTags()
  const groupTagNames: string[] = []
  for (const group in groupedTags) {
    groupTagNames.push(group)
    tagWriter.write(`\nexport interface ${group}Tags {\n`)
    const tags = groupedTags[group].sort((a, b) => cmp(a.tag, b.tag))
    tags.forEach(tag => {
      tagWriter.write(`  ${tag.withoutGroup}: ${tag.valueType} `)
      tagWriter.write(`// ${tag.popIcon(files.length)} ${tag.example()}\n`)
    })
    tagWriter.write(`}\n`)
  }
  tagWriter.write('\n')
  tagWriter.write('export interface Tags extends\n')
  tagWriter.write(`  ${groupTagNames.map(s => s + 'Tags').join(',\n  ')} {\n`)
  tagWriter.write('  SourceFile: string\n')
  tagWriter.write('  warnings: string[]\n')
  tagWriter.write('}\n')
  tagWriter.write('\n')
  tagWriter.write('export interface GroupedTags {\n')
  tagWriter.write('  SourceFile: string\n')
  tagWriter.write('  warnings: string[]\n')
  for (const group of groupTagNames) {
    tagWriter.write(`  ${group}: ${group}Tags\n`)
  }
  tagWriter.write('}\n')
  tagWriter.end()
}).catch(err => {
  console.log(err)
}).then(() => {
  exiftool.end()
})
